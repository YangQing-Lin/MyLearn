### 前端设计

------------------

#### 导航栏（nav）：

- 大多数网站的导航栏是类似的

- 可以把导航栏专门提炼出来，在 vue 里创造一个组件（可以复用）

- 在 componets 中创建组件，命名必须有两个字母大写

- 每一个组件都由三个部分组成

  - html	写到 <template> 标签里
  - js         写到 <script> 标签里
  - css      写到 <style scoped> 标签里（加上 scoped 的作用是在这对标签里写的 css 会加一个随机字符串，使得这个样式不会影响到组件以外的部分）

- [Bootstrap](https://v5.bootcss.com/) 可以让程序员很轻松的拥有美工的能力（调包）

- 导航栏高亮，当前在哪个页面，其对应的按钮高亮

  - 取得当前在哪个页面
  - 实时返回当前 route 的内容

  ```html
   <script>
   import { useRoute } from 'vue-router'
   import { computed } from 'vue'
  
   export default {
      setup() {
          const route = useRoute();
          let route_name = computed(() => route.name)
          return {
              route_name
          }
      }
   }
   </script>
  ```

  

---------------------------------

#### 内容（content）：

- 区别每个网站的是内容区域

- 每个页面创建一个单独的组件（一般在 views 里创建），且因为每个页面可能还会有多个组件，所以每个模块在 views 里创建一个单独的文件夹管理

- 各个页面应有自己的主页面（索引），每个页面同样由（html，js，css）组成

  - PK 
    - 游戏区域，为了方便单独创建一个组件 PlayGround 来写
      - 板子
  - Record 
  - Ranklist
  - User Bots
  - 404 
    - NotFound

- 将每个页面的内容用一块区域框起来（card）在 Bootstrap 里找

  ```html
  <div class="container">
  	<div class="card">
  		<div class="card-body">
  			<slot>要填充的内容</slot>
  		</div>
  	</div>
  </div>
  ```

  因为每个页面都需要 card，所以是公共的部分，公共的部分可以作为一个组件

-----------------------------------------------

#### 实现内容跳转：

- 随着链接的变化，跳转到对应的页面

- 主页中 <router-view> 会自动根据网址变化

- 其变化方式在 router 文件夹的 index.js 中定义
- 输入网址后重定向到 pk 页面
- 输入不正确的链接，重定向到 404 页面
- 在导航栏中点击按钮，跳转到对应的界面
  - 前后端分离模式可以实现，点击后，不刷新（单页面的应用）
  - vue router组件提供了一个标签实现这个功能，即把 <a> 标签换成 <router-link> 标签

------------------

#### 游戏页面：

- ##### 地图

  - 完全对称
  - 周围一圈都是墙
  - 中间是空地，空地里会随机一些障碍物
  - 一方从左下角出发，一方从右上角出发
  - 保证左下角和右上角是连通的（不能把某一方困住）
  - 每次刷新可以得到新的地图

-----------------------------

#### 实现游戏操作：

- ##### 在游戏里，如何实现一个物体在 “动”

  - 每一次渲染的画面称为帧，每到下一帧时，下一帧就把上一帧覆盖掉
  - 假设地图 1 秒钟刷新 60 次，即 1 秒有 60 帧（1 秒刷新 60 张图片），那么就可以动态的计算出这个物体在每一帧里的位置是什么，然后把他渲染出来
  - 当每秒极速放映这 60 张图片时，就可以实现看到物体在 “动”

- **需要写一个基类**：每秒钟所有游戏对象刷新 60 次

  - 一般浏览器默认每秒钟刷新 60 次

  - 浏览器有```requestAnimationFrame()```函数，可以传一个函数，那么这个函数就会在下一帧浏览器渲染之前执行一遍，想要在每一帧都执行，则需要写成递归函数

    ```js
    const step = () => {
        requestAnimationFrame(step)
    }
    requestAnimationFrame(step)
    ```

  - 创建对象

    ```js
    constructor() {
    	AC_GAME_OBJECTS.push(this);
    	this.timedelta = 0; // 这一帧执行的时刻距离上一帧执行的时刻的时间间隔（速度）
    	this.has_called_start = false; // 记录有没有执行过 start 函数
    }
    ```

  - 部分操作是创建的时候执行一次，求坐标，初始化等

    ```js
    start() { // 只执行一次
    
    }
    ```

  - 每一帧执行一次，除了第一帧之外

    ```js
    update() { // 每一帧执行一次，除了第一帧之外
    
    }
    ```

  - 删除之前执行

    ```
    on_destroy() { // 删除之前执行
    
    }
    ```

  - 删除操作

    ```js
    destroy() { // 删除操作
        this.on_destroy();
        
    	for (let i in AC_GAME_OBJECTS) {
    		const obj = AC_GAME_OBJECTS[i];
    		if (obj == this) {
    			AC_GAME_OBJECTS.splice(i);
    			break;
    		}
    	}
    }
    ```


- ##### 实现游戏操作完整代码：

  ```js
  const AC_GAME_OBJECTS = [];
  
  export class AcGameObject {
      constructor() {
          AC_GAME_OBJECTS.push(this);
          this.timedelta = 0; // 这一帧执行的时刻和上一帧执行的时刻的间隔（物体移动的速度）
          this.has_called_start = false; // 记录有没有执行过 start 函数
      }
  
      start() { // 只执行一次
  
      }
  
      update() { // 每一帧执行一次，除了第一帧之外
  
      }
  
      on_destroy() { // 删除之前执行
  
      }
  
      destroy() { // 删除操作
          this.on_destroy();
  
          for (let i in AC_GAME_OBJECTS) {
              const obj = AC_GAME_OBJECTS[i];
              if (obj == this) {
                  AC_GAME_OBJECTS.splice(i);
                  break;
              }
          }
      }
  
  }
  
  
  let last_timestamp; // 上一次执行的时刻
  const step = timestamp => { // 每一帧都执行一遍，传入参数 timestamp 为当前执行的时刻
      for (let obj of AC_GAME_OBJECTS) {
          if (!obj.has_called_start) {
              obj.has_called_start = true;
              obj.start();
          } else {
              obj.timedelta = timestamp - last_timestamp;
              obj.update();
          }
      }
  
      last_timestamp = timestamp;
      requestAnimationFrame(step)
  }
  requestAnimationFrame(step)
  ```

--------------

#### 实现游戏对象

- 地图

  - 创造一个组件 GameMap.vue 和脚本

  - 在游戏区域（h * w）里找到一个最大的矩形（rows * cols）

    ```min{h / rows, w / cols}```即是每个小方格的长度

  - 由若干小格子组成，颜色深浅相间，左上角第一个是浅色，可以分为奇格和偶格

  - canvas坐标系：横着是 x，竖着是 y，与数组定义的坐标系相反

- 墙，障碍物

  - 创造一个脚本 Wall.js
  - 在 GameMap.js 里创造障碍物
  - 四周由一圈墙组成
  - 内部的障碍物关于从左上角到右下角的线轴对称，随机的时候随机一半即可
  - 要求双方连通，这样才有博弈，flord-fill 算法判断连通性

-----------------------------

##### 以上执行流程：

以上都是前端内容，每次用户在刷新浏览器的时候，都会将前端代码加载出来，加载完，pk页面会随机一个游戏地图，**该地图每秒钟会刷新 60 次**（人眼看到的是不变的），游戏地图创建完成会在里面**创建障碍物**：先四周，再随机内部障碍物，随机之后，会判断地图是不是连通的（即左下角到右上角的连通性），如果不连通就重新创建一次。

