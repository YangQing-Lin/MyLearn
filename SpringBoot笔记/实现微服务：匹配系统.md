### 实现微服务：匹配系统

2022/8/12

-------------------

#### 匹配系统的流程

当两个用户都打开对战界面匹配的时候，各自向服务器端发送一个请求，匹配过程一般会持续十几秒，因此这是个异步的过程

当服务器端接受到前端匹配游戏的请求后，由于整个过程是一个异步的过程，等待的时间是未知的，一般这种异步的过程或者计算量比较大的过程，会用一个额外的服务去操作

这里写一个专门的匹配系统：**Matching System**，这是一个另外的程序或进程，维护了一堆用户的集合，**微服务**

当服务器端接受到前端匹配游戏的请求之后，就会将这个请求发送到匹配系统，更多的请求也都会通过服务器端发送到匹配系统，则匹配系统里会有很多待匹配游戏的用户

同时匹配系统会不断的进行匹配，随着时间的推移，将当前维护的这些用户里战斗力最接近的匹配成一组，当两个用户匹配成一组之后，匹配系统就会将结果返回给服务器端，服务器端又会将结果分别返回给两个用户的前端，之后两个用户就可以在前端看到当前返回的对手是谁，**同时在服务器端创建一个游戏的过程（Game）**

因为整个过程是一个异步的过程，匹配成功的时间是未知的，当得到结果之后需要将其立即返回给前端

鉴于此，服务器端需要使用**Websocket**协议，通过这个协议，不仅客户端可以主动向服务器端发送请求，服务器端也可以主动向客户端发送请求，全双工的通信方式

--------------------------------------------------------

#### **Websocket**协议的基本原理

将前端建立的每一个**Websocket**连接在后端维护起来，整个连接就是一个`WebSocketServer`类，每有一个连接就是`new`一个该类的实例，因此每一个连接在后端都是用这样的一个实例维护，所有和该连接相关的信息都会存到对应的实例里面（独有信息存为私有变量）

多线程，每有一个连接，都会开一个新的线程来维护

---------------------

#### 将整个游戏的过程都放到服务器端完成

##### 构思

##### 服务器端应该有一个单独的任务（Game）

1. **Create Map** 为匹配成功的双方生成一个唯一的地图
2. 将这个地图传给对战双方的客户端
3. **Waiting** 等待用户的输入，等待使用一个死循环`sleep`实现，并且设置等待时间，如果超时输入就判定`lose`，如果接受到了输入，通过`judging`程序判断输入是否合法，如果不合法就`lose`，如果合法就循环`waiting`
   1. 客户端传来的输入（真人操作），读入键盘操作
   2. 接收`Bot`代码的输入，**微服务**

##### 保证双方对战的地图一致

当一组用户匹配成功之后，该任务需要为这组用户双方统一的生成当前对局的唯一的地图

##### 裁判机制

服务器端判定完游戏结果之后，再将结果返回给前端，前端只是用来画个画，不做任何判定逻辑

##### 双方蛇的移动

------------------

#### 集成`WebSocket`

<a href="https://mvnrepository.com/">Maven仓库</a>

WebSocket不是单例模式

##### 在`pom.xml`文件中添加依赖：

- `spring-boot-starter-websocket`
- `fastjson`，前后端通信

##### 添加`config.WebSocketConfig`配置类

##### 添加`consumer.WebSocketServer`类

自己实现后端向前端发送信息，异步通信过程，需要加一个锁

将连接对应的用户信息维护起来

用线程安全的哈希表维护所有的连接，key = 用户id，value = 用户id对应的连接

特殊注入`UserMapper`

##### 配置`config.SecurityConfig`

将`WebSocket`的链接放行

##### 在前端代码里调试

在store里存socket，在pk界面调试

##### 使用`JWT`验证

-----------------------

#### 实现前端界面

##### 创建匹配界面（matchground）

参考ac saber

grid布局

##### 利用`store`里存的`status`（matching / playing）切换页面

---------------

#### 实现匹配逻辑

##### 初步实现匹配过程（无Matching System）

点击开始匹配按钮就会向后端（WebSocket）发送一个请求，后端接收到该请求后，就会将该用户放到匹配池（内存）里，匹配池里人数过2，就会将这两个用户匹配成一组返回给后端，后端返回给用户

修改store里存的内容实现前端内容的改变

匹配池使用线程安全的`set`维护

##### 前后端通过`JSON`通信

--------------

#### 实现`Game`管理游戏流程

##### 在云端生成地图

对照前端生成地图的代码



