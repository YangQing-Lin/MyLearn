## 实现匹配系统——thrift服务

2022/9/22

--------------

#### 概述

与之前的room匹配机制相比，具有延时性，要解决延时性需要添加一个新的匹配模块

:star:**延时性会影响什么？**

当用户向server请求匹配时，用户需要等待匹配成功，也就是说用户**此时被阻塞了**

##### 需求：按照用户的积分或者某种隐藏分，将分数接近的用户匹配到一起

新加匹配模块，一般是一个额外的程序或者在另外的服务器上

##### 解决阻塞问题

当有一名玩家请求匹配之后（将请求发送到server），server将匹配的请求转发到**matchingserver**

matchingserver会直接将结果返回给用户，在此期间用户是**不会被阻塞的**

##### :star:thrift是干什么的？

可以让我们在另外一个地方（另外一个进程或服务器），做一些逻辑

与本身的进程是完全独立的

thrift服务可以方便的让我们**实现在两个进程之间的通信**

通信方式：通过ip地址和port端口号

##### 对于匹配系统

会持续不断的匹配

匹配系统同一时间可能有若干个玩家，匹配系统会不断的检查这些玩家，当有若干玩家符合匹配条件并匹配成功之后，将结果返回server，不会阻塞server

计算量低，放到同一台服务器没有影响

需要支持的操作：

- 每一秒，在当前已有的玩家中进行一次匹配
- 随时有玩家加入匹配系统
- 在匹配过程中，希望玩家数组不发生变化
- 每次匹配完之后，会将当前已经发来的新的请求统一加到匹配池中

##### 多线程

也就是说，**添加玩家和进行匹配是各自独立的**

所以匹配系统的内部需要**多线程**来处理：有一个线程专门进行匹配，另外多个线程接收匹配请求

##### 消息队列

当有一个新的请求发来后，此时恰好在匹配过程中，那么这个请求应该被缓存下来，等待匹配完成之后，再加入匹配池当中

这里需要**消息队列实现**

每次来一个请求，直接将该请求加到消息队列里，然后这个请求就结束了

每次匹配完之后，检查一下消息队列中是否存在新的请求，如果有的话就处理新的请求

-----------------------

#### 创建目录

与game同级，.../AcApp/match_system/

.../AcApp/match_system/thrfit，管理thrfit的配置文件

.../AcApp/match_system/src，编写具体逻辑

-------------

#### 实现match.thrift

通过**channel_name**，通知server匹配成功的信息

实现完成，通过thrift工具创建出来服务器端和客户端需要的代码

#### 实现python server

[Apache Thrift - Home](https://thrift.apache.org/)，复制官网，修改即可

安装thrift包：`pip install thrift`

##### 定义一个player类

##### python自带消息队列：`from queue import Queue`，线程安全的队列

##### 实现`add_player`将玩家加入消息队列

##### 实现匹配池

匹配池的操作：

- 初始化一个玩家数组（匹配池）

- 添加一名玩家到匹配池

- 检验两者是否匹配，`check_match`

- 匹配成功之后

- 匹配

  给所有玩家按照分数大小排序，将相邻的玩家匹配到一起

- 每次匹配之后将等待时间增加

##### :star2:生产者-消费者模型

单开一个线程（worker），该线程是一个死循环，不断的吸收消息队列里的信息，然后将信息扔给匹配池

每次匹配之后不要一直匹配，不然会把cpu占满，匹配一次之后可以sleep一秒

python开线程的库：`from threading import Thread`

新开一个线程：`Thread(target=worker, daemon=True)`

- daemon=True，表示主线程关闭，子线程也会关闭
- daemon=No，表示主线程关闭，子线程不会关闭

实现worker：

如果队列为空，就匹配一遍，然后sleep一秒，sleep过程中可能有新的请求进来，此时会没有阻塞的加入队列中

如果队列不为空，就将队列里的元素扔到匹配池里

##### 实现辅助函数：`get_player_from_queue`

从消息队列中取出元素

该队列是一个多线程的队列，因此每次取元素的时候，需要判断一下队列里是否有元素，如果有元素，就取出，如果没有元素，需要返回空

通过python消息队列的api实现

---------

#### 实现客户端发送请求

在server端的.../consumer/.../index.py

当server收到创建玩家的请求，就要向匹配系统发送申请

当匹配系统匹配成功之后，再将玩家信息发送给server，server将这三名玩家放到一个room里进行游戏

----------

#### 实现匹配系统匹配成功之后，将结果返回server

##### 对之前代码进行补充

AcApp/acapp/asgi.py，实现在匹配系统，调用server/ws的api

在匹配系统里

- 将server/ws的api引入

- 加入async，变成多线程

- 引入django的redis，因为匹配成功之后需要将**信息存在redis里**

  将room号记作“room-a.uuid-b.uuid-c.uuid”，这样可以快速找到每个人的room

匹配成功之后，将匹配到一起的玩家放到一个组里，然后广播出去

-----------

#### 接入数据库

##### 扩充数据库

在models/player增加score战斗力

更新数据库

##### 在channels里调用和修改数据库

引入数据库

由于数据库在channels里面用是异步的，但是数据库的调用是同步的，需要api**封装**：

`from channels.db import database_sync_to_async`

调用数据库需要写成函数，然后用api封装