#### 题目2：<a href="https://www.acwing.com/problem/content/145/">最大异或对</a>

--------------

##### 暴力做法： 

```c++
for (int i = 0; i < n; i ++) {
    for (int j = 0; j < n; j ++) {
        res = max(res, a[i] ^ a[j]);
    }
}
```

-------

##### 优化做法：![最大异或对](C:\Users\冬黎\OneDrive\图片\算法基础课\算法基础课第二讲\最大异或对.png)

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 3100010; // 每个数是 31 位

int n;
int a[N], son[M][2], idx;

void insert(int x) {
    int p = 0;
    for (int i = 30; i >= 0; i --) { // 从最高位开始看
        int &s = son[p][x >> i & 1]; // 看一下每个数二进制中当前这一位是什么
        if (!s) { // 如果当前结点的孩子结点不存在这位数，就加一个结点
            s = ++ idx;
        }
        p = s; // p 指向加入的结点
    }
}

int search(int x) {
    int p = 0, res = 0; // res 存的就是使得当前异或对值最大的数
    for (int i = 30; i >= 0; i --) { // 从最高位开始找
        int s = x >> i & 1; // 看一下每个数二进制中当前这一位是什么
        if (son[p][!s]) { // 如果与当前这一位二进制数相反，即是最合适的（异或值最大）
            res += 1 << i; // 为当前数贡献一个 1
            p = son[p][!s]; // 走到下一个结点
        }
        else {
            p = son[p][s]; // 如果没有最合适的，只能走到相同的数
        }
    }
    
    return res;
}

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i ++) {
        scanf("%d", &a[i]);
        insert(a[i]);
    }
    
    int res = 0;
    for (int i = 0; i < n; i ++) {
        res = max(res, search(a[i]));
    }
    
    printf("%d\n", res);
    
    return 0;
}
```

