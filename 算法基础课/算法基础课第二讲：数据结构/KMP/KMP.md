#### KMP

------------------

##### 思路：

1. 先考虑暴力做法
2. 考虑如何优化

###### 暴力做法：

```c++
s[N], p[M]; // s[N] 为模式串，p[M] 为模板串
for (int i = 1; i <= n; i ++) { // 枚举 s
    bool flag = true; // 定义一个 flag 判断是否匹配成功
    for (int j = 1; j <= m; j ++) { // 枚举 p
        if (s[i] != p[j]) {
            flag = false; // 如果不匹配的话，就返回false
            break;
        }
    }
}
```

###### 优化：

发现每次 j 往前退的时候不必退完，而是退到此时 p 中前缀和后缀相等的最大值即可，最大值可通过 p 匹配 p来表示，即 next[]