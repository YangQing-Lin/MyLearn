#### 前缀和与差分

---------------

##### 前缀和：

一个长度为 n 的数组，a[n] = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ..., a<sub>n</sub>}

前缀和数组：S<sub>i</sub>= a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>i</sub>   下标要从 1 开始   且需要定义 S<sub>0</sub>

----------------------

###### 如何求 S<sub>i</sub>

从前往后递推

```c++
for (int i = 1; i <= n; i ++)
    S[i] = S[i - 1] + a[i];
```

--------------

###### 作用：

能快速求出原数组里一段数的和

例如：求原数组当中 [l, r] 这一段数组的和，没有前缀和数组就需要循环一遍，这样做的时间复杂度是O(n)，但是有前缀和数组的话，可以这样算：S<sub>r</sub>  - S<sub>l - 1</sub>，S<sub>r</sub> = a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>l - 1</sub> + a<sub>l</sub> + ... + a<sub>r</sub>，S<sub>l - 1</sub> = a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>l - 1</sub>，前面相同项消去即得 [l, r] 这段数组的和，这样做的时间复杂度是O(0)的

-------------------

###### 一维前缀和：

1. S<sub>i</sub> = a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>i</sub>
2. sum(L, R) = a<sub>L</sub> + a<sub>L + 1</sub> + a<sub>L + 2</sub> + ... + a<sub>R</sub> = S<sub>R</sub> - S<sub>L - 1</sub>

------------------

###### 二维前缀和：

1. 初始化子矩阵

   ```c++
   for (int i = 1; i <= n; i ++ )
           for (int j = 1; j <= m; j ++ )
               s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
   ```

2. 计算

   ```c++
   s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]
   ```

----------------------------

##### 差分

---------------------

前缀和的逆运算，假设给定一个原数组 a[n]，要构造一个 b[n]，使得 a 数组是 b 数组的前缀和，即 a<sub>i</sub> = b<sub>1</sub> + b<sub>2</sub> + ... + b<sub>i</sub>，则称 b 数组是 a 数组的差分

------------------------

###### 一维差分核心操作：

将 a[L ~ R] 全部加上C，等价于：b[L] += C，b[R + 1] -= C

```c++
b[L] += C;b[R + 1] -= C
```

---------------

###### 二维差分核心操作：

给以 (x, y) 为左上角，(x, y)为右下角的子矩阵中的所有数a[i, j]，加上C

```c++
b[x1][y1] += c;
b[x2 + 1][y1] -= c;
b[x1][y2 + 1] -= c;
b[x2 + 1][y2 + 1] += c;
```



