#### bellman-ford

-------------

处理图中可能存在负权回路的问题

:star:当最短路问题中，存在负权边，最短路不一定存在

##### 思路：

1. for 循环 n 次
2. 每次遍历每条边，边用任意一个结构体来存
3. 更新最短距离

<img src="https://raw.githubusercontent.com/DaoZuQieXing/Learn/main/img/算法基础课/算法基础课第三讲：搜索与图论/bellman-ford算法思路.png" alt="system call" style="max-width: 70%">

循环完之后，可以证明所有的边都满足三角不等式

<img src="https://raw.githubusercontent.com/DaoZuQieXing/Learn/main/img/算法基础课/算法基础课第三讲：搜索与图论/bellman-ford三角不等式.png" alt="system call" style="max-width: 70%">

----------

#### bellman-ford算法可以求出来是否存在负权回路

##### 迭代的实际意义：

比如当前迭代了 k 次，那么当前求出的最短距离（dist数组）的含义是：从 1 号点经过不超过 k 条边走到每个点的最短距离

##### 如何判断存在负权回路？

现在假设第 n 次迭代的时候，**有更新距离**，所以就存在一条最短路径，该路径上的边的个数是 >= n 的，一条路径上有 n 条边意味着有 n + 1 个点，又因为总共只有 n 个点，根据抽屉原理，一定存在一个环，又因为是更新之后的最短路径，所以该环一定是负环，这样就判断出有负权回路

所以当第 n 次迭代的时候，如果有更新的话，则一定存在一条边数为 n 的最短路径，就说明存在负环

##### 不过bellman-ford算法求负环时间复杂度比较高，一般适用spfa算法求负环

##### 为什么有环就一定是负环？

因为当前路径是最短路径，由反证法：如果当前环是正环的话，那么该路径一定不是最短路径，与事实不符，所以一定是负环





