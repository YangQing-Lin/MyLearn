#### <a href="https://leetcode.cn/problems/sum-of-subsequence-widths/">子序列宽度之和</a>

-----------------

直接求的时间复杂度是 $2^n$ ，观察数据范围肯定过不了

##### 考虑每个元素对答案的贡献是多少

先将所有数**排序**，不失一般性考虑其中一个数 $a_i$，对于 $a_i$ 来说，他要么在某些集合里作为最小值出现，要么在某些集合里作为最大值出现，分情况讨论

- 如果 $a_i$ 在某些集合里作为最大值出现，这些集合的元素范围是 $[0, i - 1]$，这些元素组成的集合总共有 $2^i$ 个，由于 $a_i$ 作为最大值出现，所以在答案里加上 $a_i * 2^i$。
- 如果 $a_i$ 在某些集合里作为最小值出现，这些集合的元素范围是 $[i + 1, n - 1]$，这些元素组成的集合总共有 $2^{n - i - 1}$ 个，由于 $a_i$ 作为最小值出现，所以在答案里减上 $a_i * 2^{n - i - 1}$ 。

##### 代码细节

我们可以预处理出来 $2^n$ 的值，这样在计算 $2^n$ 时，时间复杂度是 $O(1)$ 的。

总体的时间复杂度就是 $O(n)$ 的。

##### 边界问题

如果一个集合里的元素有重复，且重复的元素是最小值或者最大值，处理的时候非常麻烦，可能会有重复计算，因为当最小值或最大值重复时候，并不知道哪个值是最小值或最大值

所以排序的时候我们按照双关键字排序 {数值，下标}，这样每个元素都是唯一的，不会有重复计算

```java
class Solution {
    public int sumSubseqWidths(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        int MOD = (int) 1e9+7;
        int[] p = new int[n]; // p[i] 表示 2^i 是多少
        p[0] = 1;
        for (int i = 1; i < n; i ++) p[i] = (p[i - 1] * 2) % MOD;

        long res = 0;
        for (int i = 0; i < n; i ++) {
            res = (res + (long) nums[i] * p[i] - (long) nums[i] * p[n - i - 1]) % MOD;
        }
        return (int) (res % MOD);
    }
}
```

