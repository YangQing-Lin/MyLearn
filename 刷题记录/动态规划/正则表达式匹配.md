#### <a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a>

----------------

#### 闫氏DP分析法

- 状态表示

  - 集合：所有s[1 ~ i ]  和 p[1 ~ j ] 的匹配方案 ，下标从1开始，取决于[1, i]里的*表示多少字符
  - 属性：bool，是否存在一个合法方案

- 状态计算

  两种情况

  - 如果 p[j] 不带*（将每一个\*与前面的一个字符看作一个整体）

    看一下s[i] 和 p[j] 是不是匹配，有两种情况

    - 一是s[i] == p[j]
    - 二是p[j] == '.'
    
    同时还要**满足 f(i - 1, j - 1)**，即 s 的前 i - 1 个字符和 p 的前 j - 1个字符要匹配
    
  - 如果 p[j] 带* ，**这就需要枚举一下，这个*表示多少个字符**
  
    - 如果*表示 0 个字符的话，需要满足 f(i, j - 2)
  
    - 如果*表示 1 个字符的话，需要满足 f(i - 1, j - 2)，且 s[i] 和 p[j] 要匹配
  
    - 如果*表示 2 个字符的话，需要满足 f(i - 2, j - 2)，且 s[i], s[i - 1] 和 p[j] 要匹配
  
      ......

综上所述，状态的数量是 n<sup>2</sup>，如果 p[j] 有*，需要枚举一下（O(n)），所以时间复杂度是 **n<sup>3</sup>**

**对状态转移方程优化：**

下式子 s[i] 表示 s[i] 和 p[j] 匹配

对于状态计算的第二种情况：且表示`&`
$$
f(i,j)=f(i,j-2)|f(i-1,j-2)且s[i]|f(i-2,j-2)且s[i]且s[i-1]|...
$$
考虑以下式子：同样的分析方式
$$
f(i-1,j)=f(i-1,j-2)|f(i-2,j-2)且s[i-1]|f(i-3,j-2)且s[i-1]且s[i-2]|...
$$
不难发现，两个式子有相同处

则状态转移方程可以表示为：
$$
f(i,j)=f(i,j-2)|f(i-1,j)且s[i]
$$
那么状态计算的第二种情况的状态转移方程是 O(1) 的，整个算法的时间复杂度降到了 **n<sup>2</sup>** 

##### 代码：

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int n = s.length(), m = p.length();
        s = ' ' + s; // 为了方便，使下标从1开始，所以前面加上一个空白符
        p = ' ' + p;
        boolean[][] f = new boolean[n + 1][m + 1];
        f[0][0] = true;
        for (int i = 0; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) { // j 从1开始，因为p的第一个字符是空白符，不可能匹配
                if (j + 1 <= m && p.charAt(j + 1) == '*') continue; // 特判：将*和其前面的一个字符看成一个整体
                if (i > 0 && p.charAt(j) != '*') { // 状态计算的第一种情况
                    f[i][j] = f[i - 1][j - 1] && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.');
                } else if (p.charAt(j) == '*') { // 状态计算的第二种情况
                    f[i][j] = f[i][j - 2] || i > 0 && f[i - 1][j] && (s.charAt(i) == p.charAt(j - 1) || p.charAt(j - 1) == '.'); // 这里是s[i]和p[j - 1]匹配，p[j]是*
                }
            }
        }
        return f[n][m];
    }
```

