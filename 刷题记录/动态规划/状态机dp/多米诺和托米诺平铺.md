#### <a href="https://leetcode.cn/problems/domino-and-tromino-tiling/">多米诺和托米诺平铺</a>

----------------

##### 状态表示

- 集合：f(i, j) 表示铺满前 i - 1列，且第 i 列的状态为 j 的所有方案
- 属性：方案总数

##### 状态计算：

对于第 i 列，一共有四种状态：`00, 10, 01, 11`，则对于这四种状态，分别可以转移到第 i + 1列的状态，有以下转移矩阵：

| 状态转移矩阵，下边是当前状态，右边是下一个状态0表示不可以转移，1表示可以转移 | 00   | 10   | 01   | 11   |
| ------------------------------------------------------------ | ---- | ---- | ---- | ---- |
| 00                                                           | 1    | 1    | 1    | 1    |
| 10                                                           | 0    | 0    | 1    | 1    |
| 01                                                           | 0    | 1    | 0    | 1    |
| 11                                                           | 1    | 0    | 0    | 0    |

根据以上转移矩阵，我们可以得知当前的状态可以转移到哪些状态

```java
class Solution {
    public int numTilings(int n) {
        int MOD = (int) 1e9 + 7;
        int[][] w = { // 状态转移矩阵
                {1, 1, 1, 1},
                {0, 0, 1, 1},
                {0, 1, 0, 1},
                {1, 0, 0, 0},
        };

        int[][] f = new int[n + 1][4]; // 铺满前 i-1 列，且 i 列的状态为 j 的所有方案数，则答案为 f[n][0]
        f[0][0] = 1;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < 4; j ++) { // 枚举当前的状态，根据状态转移矩阵转移状态
                for (int k = 0; k < 4; k ++) { // 枚举下一个状态，并通过状态转移矩阵判断当前状态是否可以转移到下一个状态
                    f[i + 1][k] = (f[i + 1][k] + f[i][j] * w[j][k]) % MOD;
                }
            }
        }
        return f[n][0];
    }
}
```

